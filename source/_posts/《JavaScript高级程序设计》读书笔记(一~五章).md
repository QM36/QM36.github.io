---
title: JS高程一到五章读书笔记
---

## 第一章 JavaScript简介
`JavaScript`是这一种专门为网页交互而设计的脚本语言，由以下三个部分组成：
1. `ECMAScript`，提供核心语言功能
2. 文档对象模型（`DOM`），提供访问和操作网页内容的方法和接口
3. 浏览器对象模型(`BOM`),提供与浏览器交互的方法和接口

## 第二章 在HTML中使用JavaScript
#### 1. <script>元素
`<sctipt>`定义了六个可选属性，以下只介绍常用的几种：
* `src`：可选，表示包含要执行代码的外部文件
* `type`：可选，表示编写代码使用的脚本语言的内容类型，人们一直以来使用的都是`text/javascript`
* `charset`：可选。表示通过`src`属性指定的代码的字符集，由于大多数浏览器会忽略它的值，因此很少人使用这个属性
* `defer`：可选，表示脚本可以延迟到文档被解析和显示之后再执行，只对外部脚本文件有效

使用`<script>`元素的方式有两种，直接在页面中嵌入`JavaScript`代码和包含外部`JavaScript`文件
* 嵌入代码：

```html
<script type="text/javascript">
    function sayHi(){
        alert("Hi!");
    }
</script>
```
包含在`<script>`元素内部的代码，将会被从上至下依次解释，解释器会解释一个函数的定义，然后将该定义保存在自己的环境中，在解释器对`<script>`元素内部的所有代码求值完毕以前，页面中的其余内容都不会被浏览器加载或显示。

在嵌入代码中不要出现`</script>`，否则就会产生一个错误，为了解决这个问题，可以使用转义字符`\`，写成`<\/script>`。

* 外部文件：

```html
<script type="text/javascript" src="example.js"></script>
```
`src`属性是必须的，这个属性指向外部`JavaScript`文件的连接，外部文件`example.js`将被加载到当前页面，在解析外部文件时页面的处理会暂时停止。需要注意是，带有`src`属性的`<script>`元素的开始和结束标签之间不应该包含其他`js`元素，如果包含了嵌入代码，则只会下载并执行外部脚本文件，嵌入的代码会被忽略

#### 2. 标签的位置
按照传统的做法，所有`<script>`元素都应该放在页面的`<head>`元素中，这种做法的目的就是把所有外部文件（包含`CSS`文件和`js`文件）的引用都放在相同的地方。但是在文档`<head>`元素包含所有的`js`文件，意味着必须等到全部`js`代码都被下载解析和执行完成以后，才开始呈现页面的内容。这就会导致浏览器在呈现页面时出现明显的延迟，而延迟期间的浏览器是一片空白，为了避免这个问题，现代`Web`应用程序一般把全部`js`引用放在`<body>`元素页面内容的后面。这样在解析`js`代码之前，页面的内容将完全呈现在浏览器中，打开页面的速度也会加快。

#### 3. 延迟脚本
`<script>`标签定义了`defer`属性，这个属性表明脚本在执行时不会影响到页面的构造，就是说，脚本会延迟到整个页面都解析完毕再运行。即使把延迟脚本放在`<head>`标签中，也会后与`html`渲染结束再执行。由于多个延迟脚本的执行顺序不确定，所以最好有一个延迟脚本，且需要把脚本放在页面最底部。

#### 4. 异步脚本
`<script>`元素定义了`async`属性，这个属性与`defer`属性类似，只适用外部脚本文件，并且告诉浏览器立即下载文件，与`defer`不同的是，标记为`async`的脚本并不保证按照指定它们的先后执行顺序。指定该属性是不让页面等待脚本的下载和执行，从而异步加载页面其他内容，为此，建议异步脚本不要在加载期间修改`DOM`

#### 5. 嵌入代码与外部文件
一般认为最好的做法就是尽可能的使用外部文件来包含`js`代码，外部文件具有如下优点：
* 可维护性：把所有`js`代码都放在一个文件夹中，维护很方便，使得开发人员在不接触`html`标记的情况下，集中精力编辑`js`
* 可缓存：如果有两个页面都是使用同一个文件，那么这个文件只需下载一次，因此最终结果是能够加快页面加载的速度
* 适应未来：通过外部文件包含`js`无须使用`XHTML`或`back`，`HTML`和`XHTML`包含外部文件的语法是相同的

## 第三章 基本语法

#### 1. 语法
* 区分大小写
    
    在`js`中，大小写是不同的
* 标识符

    标识符是指变量、函数、属性的名字，或者函数的参数。标识符的第一个字符必须是字母，下划线（`_`）或者一个美元符号（`$`），其他字符可以是字母
    、下划线、美元符号或数字。按照惯例标识符采用驼峰大小写格式，就是第一个字母小写剩下的单词首字母大写。
* 注释

    单行注释以`//`开头，块级注释以`/*`开头，以`*/`结尾。中间行可以以一个星号开头，提高代码可读性
* 严格模式

    严格模式下，一些不确定的行为得到处理，而且对某些不安全的操作也会抛出错误，要在整个脚本中启用严格模式，可以在顶部添加`"use strict"`，其实它是一个编译指示，用于高速支持`js`引擎切换到严格模式
* 语句

    在语句结尾尽量加`;`,`if`语句后面的内容也尽量跟`{}`
#### 2. 关键字和保留字

关键字有特殊用途，可以用于表示控制语句的开始或结束，或者用于执行特定操作符，按照规则，关键字也是语言保留的，不能用作标识符

#### 3. 变量

`js`的变量是松散型的，每个变量仅仅是一个用于保存值得占位符而已，定义变量只需要`var`操作符，后面跟一个变量名即可。每个变量都有一个默认的值`undefined`

关于变量的赋值可以直接在声明之后赋值，并且可以多个变量一起赋值，由于是弱类型，所以不同类型的初始化可以放在一条语句中午完成
```js
var message = 'hi',found = false,age = 29
```
`var`出现的位置标志着变量的作用域，如果没有`var`则变量为全局变量
#### 4. 数据类型
* typeof操作符

    `typeof`操作符用来检测给定变量的数据类型。它是操作符而不是函数，有些例子中带有圆括号，是不需要的，需要注意的是如果这个值是`null`，对象或函数都会返回`object`
* undefined类型

    在声明变量时候没有赋值就会使得变量有一个默认值`undefined`
* null类型

    表示一个空对象指针，只要有意保存对象的变量还没有真正保存对象，就应该明确让变量保存`null`值
* boolean类型

    该类型只有两个字面值`true`和`false`，注意是区分大小写的，还有在`if`语句判断中，会自动转换布尔类型，任何一个对象都会转换为`true`，这一点至关重要，错误地使用一个对象而不是布尔值，就有可能彻底改变应用程序流程
* number类型

    这种类型用来表示整数和浮点数，最基本的数值字面量格式是十进制，整数还可以通过八进制或十六进制的字面值来表示，其中八进制字面量的第一位必须是零，然后才是八进制序列，如果字面值的数值超过了范围（0-7），那么前导`0`将被忽略，后面的数值将被当做十进制数值解析。八进制字面量在严格模式下是无效的，十六进制字面值得前两位必须是`0x`，后跟任何十六进制数字的字母可以是大写也可以是小写。在进行八进制和十六进制表示的数值最终都将被转换为十进制。
    
    有按个函数可以把非数值转换为数值，`Number()`,`parseFloat()`,`parseInt()`第一个函数，可以转换任何数据类型，如果是布尔类型，`true`为`1`,`false`为`0`，如果是`null`为`0`,如果是字符串会把所有在范围内的八进制与十六进制转换为十进制，如果是对象，则调用对象的`valueOf()`，然后依照前面的规则转换返回的值，如果转换的结果是`NaN`，则调用对象的`toString()`方法，然后再次依照前面的规则转换返回的字符串值
* string类型

    字符串可以用双引号或单引号表示。字符串包含一些特殊的字符字面量，也叫转义序列，用于换行制表，空格等用途，不多赘述，不管转义字符多长都表示一个字符。
    
    字符串的特点是不可变的，一旦创建它们的值就不能改变，要改变某个变量保存的字符串，首先要毁掉原来的字符串，然后再用另一个包含新值得字符串填充该变量
    
    ```js
    var lang = 'java';
    lang += 'script'
    ```
    在以上例子中，其实是创建一个能容纳十个字符的字符串，先赋值`java`，再赋值`script`，最后删掉之前的两个字符串
    
    要把一个值转换为字符串有两种方式，第一种是`toString()`方法，这个方法唯一要做的就是返回相应值得字符串表现。数值，布尔值，对象和字符串值都有该方法，但是`null`和`undefined`没有这个方法。`toString()`可以带一个参数，用来表示基数。默认情况下，该方法以十进制返回数值的字符串表示，传递基数之后，可以输出二进制、八进制、十六进制甚至其他有效进制格式表示的字符串值。
    
    在不知道转化之后的值是不是`null`和`undefined`，可以用转型函数`String()`这个函数能够将任何类型的值转换为字符串。
* object类型

    对象可以通过执行`new`操作符后跟要创建的对象类型的名称来创建。`Object`类型所具有的任何属性和方法也同样存在于更具体的对象中，`Onject`的每个实例都具有下列属性和方法：`constructor`-保存用于创建当前对象的函数；`hasOwnProperty(propertyName)`-用于检查给定的属性在当前对象实力中（不是实例的的原型），其参数以字符串形式指定；`isPrototypeOf(object)`-用于检查传入的对象是否传入对象的原型；`propertyIsEnumerable(propertyName)`-用于检查给定的属性是否能够使用`for-in`语句；`toLocaleString()`-返回对象的字符串表示，该字符串与执行环境的地区对应。`toString()`-返回对象的字符串表示。`valueOf()`-返回对象的字符串、数值或布尔值表示。通常与`toString()`方法的返回值相同。

#### 5. 操作符
* 一元操作符

    只能操作一个值得操作符叫做一元操作符。包括递增和递减操作符、一元加减操作符
* 位操作符

    位操作符的操作数是`32`位比特序列由`0`和`1`组成，具体包括有**按位非`~`**-返回数值反码；**按位与`&`**-有两个操作数，将两个数值的每一位对齐，然后对相同位置桑的两个数执行`AND`操作；**按位或`|`**-有两个操作数两个操作数相同位置的数字进行或操作；**按位异或`^`**-两个操作数，进行异或操作（相同为`0`，不同为`1`）；**左移`<<`**-将数值的所有位向左移动指定的位数，就是扩大`2`的倍数；**有符号的右移`>>`**-这个操作符会将数值向右移动，但是保留符号位，有符号的右移操作与左移操作恰好相反；**无符号右移`>>>`**-将数值的所有`32`位都向右移动，对正数来说有无符号都一样，但是负数的符号位也会向右移动，多余的位置会补`0`，正负会发生改变
* 布尔操作符

    **逻辑非`!`**-无论这个值是什么数据类型，这个操作符都会返回一个布尔值，逻辑非操作符首先会将它的操作数转换为一个布尔值，然后再对其求反；**逻辑与`&&`**-有两个操作数，逻辑与操作可以应用到任何类型，不仅仅是布尔值（逻辑与属于短路操作，如果一个操作数是`false`，无论另外一个是什么，结果都会是`false`,如果其中一个是`true`,其结果就会取决于另外一个操作数）；**逻辑或`||`**操作数不一定是布尔值，如果一个操作符的求值结果为`true`，就不会对第二个操作数求值，如果两个操作数都是`false`,才会返回`false`
* 乘性操作符

    乘性操作符有三个：乘法`*`、除法`/`和求模`%`。
* 加减操作符

    包括加法`+`与减法`-`,如果操作数中遇到了字符串布尔值`null`或`undefined`，先会调用其`Number()`函数将其转换为数值，如果遇到对象会调用`valueOf()`和`toString()`转换为数值进行加减，如果转换结果为`NaN`，最后计算结果也是`NaN`
* 关系操作符

    小于、大于、小于等于和大于等于这几个关系操作符作用于对两个数值进行比较，这几个操作符都返回布尔值,所有类型的操作数都会先转换为数值，进行比较之后返回一个布尔值，就连字母组成的字符串也会根据字符编码比较大小，而不是字母出现的先后顺序，数字组成的字符串也是根据字符编码比较，在比较数字与字符串时，字符串会转换为数值进行比较，如果转换结果为`NaN`,结果无论如何都是`false`
* 相等操作符

    有两组操作符：相等`==`和不相等`!=`，全等`===`和不全等`!==`,前一组会发生强制类型转换，比较是否相等，后一组不会转换，会比较类型和数值是否相等
* 条件操作符

    ```js
    variable = boolean_expression ? true_value : false_value;
    ```
    这行代码的含义就是基于对`boolean_expression`求值结果，决定变量该怎么赋值，如果求值结果为`true`,赋值为`true_value`，否则赋值`false_value`
* 赋值操作符

    简单赋值操作符用等号`=`表示，其作用就是把右侧的赋值给左侧，复合赋值操作就是在等号前面添加乘性操作符，加性操作符或位操作符
* 逗号操作符

    使用逗号可以在一条语句中执行多个操作，逗号操作符用于声明多个变量，除此之外逗号操作符还可以用于赋值，用于赋值时逗号操作符总会返回表达式中的最后一项
    ```js
    var num = (5,1,4,8,0)//num = 0
    ```
#### 6. 语句
* if语句

    用于条件判断，表达式求值结果不一定是布尔值，求值结束后会将这个值转换为布尔值，如果值为`true`会执行`if`代码块后的，否则执行`else`代码块中语句，推荐使用代码块
* do-while语句

    是一种后测试循环语句，只有带循环体中的代码执行之后，才会测试出口条件，即无论求值结果如何，循环体内的代码至少执行一次
* while语句

    这是前测试循环语句，即在循环体内的代码被执行之前，就会对出口条件求值，因此循环体内的代码有可能一次都不会执行
* for语句

    是一种前测试循环语句，具有在执行循环之前初始化变量和定义循环后要执行的代码的能力。由于`for`循环不存在块级作用域，因此在循环内部定义的变量也可以在外部访问，如果将表达式中的语句全部省略，就会形成无限循环
* for-in语句

    该语句是一种精准的迭代语句，用来枚举对象的属性
    ```js
    for(var propName in window) {
        document.write(propName);
    }
    ```
    这个例子中使用`for-in`显示浏览器中全局对象`window`中的属性。如果要迭代的对象的变量值为`null`或`undefined`，`for-in`语句会抛出错误，ES5为了更正这一行为，对这种情况不再抛出错误，而是停止执行循环体，所以为了保证兼容性，在使用该语句之前，先检测该对象的值是否是`null`或`undefined`
* label语句

    使用该语句可以在代码中添加标签，以便将来使用
    ```js
    start:for(var i = 0; i < count; i ++ ) {
        alert(i);
    }
    ```
    这个例子中`start`标签可以将来由`break`或`continue`语句引用，加标签的语句一般都要与`for`等循环语句配合使用
* break和continue语句

    `break`和`continue`语句用于在循环中精确地控制代码的执行。其中，`break`语句会立即退出循环，制继续执行循环后面的语句。而`continue`语句虽然也是立即退出循环，但退出循环后会从循环的顶 部继续执行
    
    `break`和`continue`语句都可以与`label`语句联合使用，从而返回代码中特定的位置。这种联合使用的情况多发生在循环嵌套的情况下
* with语句

    不建议使用
* switch语句

    `switch`与`case`搭配使用，需要注意的是，在每个`case`语句最后需要加`break`否则会顺序执行，最后的`default`关键字则用于在表达式不匹配前面任何一种情形的时候
    
    `switch`语句可以使用任何数据类型，无论是字符串还是对象都可以，其次，`case`的值不一定是常量，可以是变量甚至是表达式

#### 7. 函数
* 理解参数

    函数不介意传递参数的个数与类型，因为`ECMAScript`中的参数在内部是用一个数组来表示的，函数接收的任何元素都是数组，如果这个数组不包含任何元素，也没有关系。在函数体内部可以通过`arguments`对象来访问这个参数数组，它可以与命名参数一起使用,`arguments`的长度是由传入的参数的哥说决定的，而不是定义函数的命名参数的个数决定的。`arguments`和传入的参数是不同的访问空间，但是值会同步，因为`ECMAScript`中的所有参数传递的都是值，不可能通过引用传递参数。
* 没有重载
    在其他语言中重载指的是给一个函数写多个定义，只要这个定义的签名（接受的参数的类型和数量）不同就是函数的重载，但是在`ECMAScript`中函数没有签名，因为它的参数是由包含零或多个值得数组来表示的，没有函数签名，因此也就没有重载。如果在`ECMAScript`中定义了两个名字相同的函数，则该名字只属于后定义的函数，后定义的函数会覆盖先定义的函数

## 第四章 变量、作用域和内存问题
由于`js`变量松散类型的本质，决定了它只是在特定时间用于保存特定值得一个名字而已，由于不存在定义某个变量必须要保存何种数据类型的值得规定，变量的值及其数据类型可以在脚本的生命周期内改变

#### 1. 基本类型和引用类型的值
`ECMAScript`变量包含两种数据类型的值，基本类型值和引用类型值，基本类型值指的是简单的数据段，引用类型值指那些可能由多个值构成的对象。基本类型是按值访问的，因为可以操作保存在变量中的实际的值，引用类型的值是保存在内存中的值，`js`不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间，在操作对象时，实际上是操作对象的引用而不是实际的对象，因此引用类型的值是按引用访问的。
* 动态的属性

    定义基本类型和引用类型值得方式类似，都是创建一个变量，为这个变量赋值，但是这个值一旦保存到变量中之后，对不同类型的值得操作就不同了，对于引用类型，可以为其添加属性和方法，也可以改变和删除属性和方法。只能给引用类型值（对象）动态添加属性。
    
* 复制变量值

    在从一个变量向另一个变量复制基本类型和引用类型值得时候也是不同的。
    
    如果是基本类型变量，复制的时候会在变量对象上创建一个新值，然后把这个值复制给新变量
    ```js
    var name1 = 5;
    var name2 = name1;
    ```
    在以上例子中，`name1`保存的值是`5`，使用前者来初始化后者，`name2`也保存了`5`,但是两者的`5`是相互独立的，这个值只是`name1`中`5`的一个副本，这两个变量可以参与任何操作而不会相互影响。
    
    如果是引用类型，也会将存储在变量对象中的值复制一份放到一个新变量分配的空间中，不同的是这个值得副本实际上是一个指针，而这个指针指向存储在堆中的一个对象，复制结束后，这两个变量实际上将引用同一个对象，因此改变其中一个变量，就会影响另一个变量
    
* 传递参数

    所有函数的参数都是按值传递的，就是说，把函数外部的值复制给函数内部的参数，就和把一个变量复制到另一个变量一样。基本类型值的传递如同基本类型变量的复制一样，引用类型值得传递，如同引用类型值的复制一样，因此引用类型的传递在局部作用域中修改的对象会在全局作用域中反映出来，但并不是按引用传递的。访问变量有按值和按引用，但是参数只能按值传递。
    ```js
    function setName (obj) {
        obj.name = "Nicholas";
        obj = new Object();
        obj.name = "Greg";
    }
    var person = new Object();
    setName(person);
    alert(person.name); //Nicholas
    ```
    在以上例子中，把`person`传递给函数只有，其`name`属性发生改变，之后又将一个新对象赋值给变量`obj`，同时将其`name`属性值设置为`Greg`，如果`person`是按照引用传递的，则`person`就会自动修改为指向`name`属性为`Greg`的新对象，但是访问`person.name`结果是`Nicholas`，这说明即使在函数内部修改了参数的值，但是原始的引用仍然保持不变，实际上，在函数内部重写`obj`时，这个变量引用的就是一个局部对象了，而这个局部对象会在函数执行完毕之后立即销毁。
    
* 检测类型

    `typeof`可以检测一个变量是不是基本类型的数据，可以确定字符串、数值、布尔值、还是`undefined`，但是如果变量的值是一个对象或者`null`，`typeof`都只会返回`object`。在检测引用类型的值时，会使用`instanceof`操作符
    ```js
    alert(person instanceof Object); // 变量 person 是 Object 吗? 
    alert(colors instanceof Array); // 变量 colors 是 Array 吗? 
    alert(pattern instanceof RegExp); //变量pattern是RegExp吗?
    ```
    所有引用类型的值都是`Object`的实例。因此，在检测一个引用类型值和`Object`构造函数时,`instanceof`操作符始终会返回`true`。当然，如果使用`instanceof`操作符检测基本类型的值，则该操作符始终会返回`false`,因为基本类型不是对象

#### 2. 执行环境及其作用域
执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为，每个执行环境都有一个与之关联的**变量对象**，环境中定义的所有变量和函数都保存在这个对象中，我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。

全局执行环境是最外围的一个执行环境，在`web`浏览器中，全局执行环境被认为是`window`对象，因此所有全局变量和函数都是作为`window`对象的属性和方法创建的。某个执行环境中的所有代码执行完毕之后，这个环境被销毁， 保存在其中的所有变量和函数定义也随之销毁，但是全局执行环境直到应用程序退出之后才会被销毁

每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境就会被堆入到一个环境栈中，而在函数执行结束之后，栈将其环境弹出，把控制权返回给之前的执行环境。

当代码在一个环境中执行时，会创建变量对象的一个作用域链，作用域链保证对执行环境有权访问的所有变量和函数的有序执行。作用域链由环境的变量对象组成序列。作用域链中的下一个变量对象来自包含环境，再下一个变量对象来自下一个包含环境，这样一直延续到全局执行环境，全局执行环境的变量对象始终都是作用域链中的最后一个对象

标识符的解析是沿着作用域链一级一级的搜索，搜索过程始终从作用域链的开始逐级向后，直至找到标识符为止（如果找不到标识符，就会导致错误发生）

```js
var color = "blue";
function changeColor() {
    if (color === "blue") {
        color = "red";
    } else {
        color = "blue";
    }
```
在以上例子中函数`changeColor`的作用域链包括两个对象，一个自己的变量对象一个全局环境的变量对象，可以在函数内部访问变量`color`，因为可以在作用域中找到它

内部环境可以通过作用域链访问所有的外部环境，但是外部环境不能访问内部环境中的任何变量和函数，这些环境之间是线性的，有次序的，每个环境变都可以向上搜索作用域链，以查询变量和函数名，但是任何环境都不能通过向下搜索作用域链而进入另一个执行环境

* 延长作用域链

    有些语句可以在作用域链的前端临时增加一个变量对象，这个变量会在代码执行之后被移除，这就会延长作用域链，这样的语句有如下两个：`try-catch`语句的`catch`块和`with`语句
* 没有块级作用域

    在`js`，用花括号封闭起来的代码没有自己的作用域，尤其注意`if`和`for`语句
    ```js
    if (true) {
        var color = "blue";
    }
    for (var i=0; i < 10; i++){
        doSomething(i);
    }
    ```
    在以上例子中，两个语句中的变量`color`和`i`并不会在语句执行完之后销毁，而是存在在外部的环境中
    
    * 声明变量
        
        使用`var`声明的变量会自动被添加到最接近的环境中。在函数内部，最接近的环境就是函数的局部环境;如果初始化变量时没有使用`var`声明，该变量会自动被添加到全局环境
        
    * 查询标识符
    
        在某个环境中为了读取或写入而引入一个标识符时，必须通过搜索来确定该标识符代表的是什么，搜索会先从前端开始，如果在局部环境中找到，就会停止搜索，如果没有找到就会在全局环境中搜索。这也会造成同一个标识符在局部中的意义会覆盖全局的意义，因为局部一旦找到就会停止。虽然访问局部变量比访问全局变量更快，但是`js`引擎在这方面的优化，所以使得两者的搜索差别不会太大   

#### 3. 垃圾收集
`js`具有自动垃圾收集机制，不需要开发人员手动跟踪，原理就是找到不需要继续使用的变量，然后释放其占有的内存。因此垃圾收集机制会在固定的时间间隔周期的性的执行这一操作。

函数中局部变量的正常生命周期如下：首先为句局部变量在栈或堆中分配相应的空间，直至函数执行结束，这些变量就没有用了，这个时候开业释放他们的内存。垃圾收集机制必须跟踪哪个变量是有用的哪个是没用的，对于不再使用的打上标记，以备将来回收，用于标识无用变量的策略可能会因实现而异，具体到浏览器中的实现，通常有两种策略——标记清除和引用计数

* 标记清除

    当变量进入环境时，就会给这个变量标记为“进入环境”，并且永远不能释放进入环境的变量所占用的内存，当变量离开环境时，则将其标记为“离开环境”，最后垃圾收集器完成内存清除工作
* 引用计数

    引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那些引用次数为零的值所占用的内存。
    
    但是当循环引用时，这种策略不能解决。循环引用指的是对象`A`中包含一个指向对象`B`的指针，而对象`B`中也包含一个指向对象`A`的指针，这两个对象的引用次数都是2，如果这个函数被多次重复使用，他们的内存就不能得到回收,其中一个解决方法就是可以手动断开原生`js`对象之间的连接，将他们都指向`null`
* 管理内存

    分配给`Web`浏览器的可用内存数量通常要比分配给桌面应用程序的少。这样做的目的主要是出于安全方面的考虑，目的是防止运行`JavaScript`的网页耗尽全部系统内存而导致系统崩溃，因此占用最少的内存可以让页面获得更好的性能。优化内存的最佳方式就是为执行中的代码只保存必要的数据，一旦数据不可用，就接触引用（将其指向`null`）来释放内存。不过解除一个值的引用并不意味着自动回收该值所占用的内存，解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。


## 第五章 引用类型
引用类型的值（对象）是引用类型的实例，引用类型是一种数据结构，用于将数据和功能组织一起。新对象使用`new`操作符后跟一个构造函数来创建，构造函数本身就是一个函数，只是这个函数是出于创建新对象而定义的

#### 1. Object类型
创建`object`实例有两种方式，一种是`new`操作符后跟构造函数，一种是对象字面量表示法。

访问对象属性有两种方式：点表示法和方括号
```js
alert(person["name"]); //"Nicholas" 
alert(person.name); //"Nicholas"
```
在以上例子中，两种访问方式没有任何区别，但是方括号语法可以通过变量来访问属性
```js
var propertyName = "name"; 
alert(person[propertyName]); //"Nicholas"
```
如果属性名中包含会导致语法错误得字符，或者属性名使用的是关键字或保留字，也可以使用方括号表示
```js
person["first name"] = "Nicholas";
```
由于`first name`中包含一个空格，所以不能使用点表示法来访问。通常情况下，除非必须使用变量访问属性，一般都用点表示法。

#### 2. Array类型

`ECMAScript`数组的每一项可以保存任何类型的数据，而且数组的大小是可以动态调整的，可以随着数据的添加自动增长以容纳数据

创建数组有两种方式，一种是`new`后跟构造函数，同时也可以省略`new`操作符，另一种是数组字面量，用方属性的值，括号来表示。构造函数中可以传入参数，如果是数值，则这个数值会变成数组的`length`，数组就会有多少项，如果传递的是其他类型的参数，则会创建包含那个值得只有一项的数组。数组的索引用方括号，数组的`length`属性不是只读的，可以修改。

* 检测数组

    在一个全局作用域而言，使用`instanceof`操作符就能得到满意的结果，但是如果网页中包含多个框架，实际上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的`Array`构造函数，如果从一个框架向另一个框架传入一个数组，那么传入的数组与在第二个款框架中原生创建的数组分贝具有各自不同的构造函数。
    
    为了姐解决这个问题，可以用`Array.isArray()`方法，这个方法的目的是最终确定某个值是不是数组，而不管它是在哪个全局执行环境中创建的。
* 转换方法

    所有对象都具有`toLocaleString()`、`toString()`和`valueOf()`方法，调用数组的`toString()`方法会返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔符的字符串
    
    如果使用`join()`方法，则可以使用不同的分隔符来构建这个字符串，`join()`方法只接收一个参数，即用作分隔符的字符串，然后返回包含所有数组项的字符串，它的默认分隔符是逗号
* 栈方法

    `ECMAScript`数组提供了一种让数组行为类似于其他数据结构的方法，数组可以表现的像栈一样，实现后进先出，实现进和出的两个数组的方法分别是`push()`和`pop()`。`pushi()`方法可以接收任意数量的参数，把它们逐个添加在数组的末尾，最后返回数组的长度，而`pop()`方法则从数组末尾移除最后一项，并减少数组`length`属性的值，然后返回移除的项。为数组增加项可以使用类似的栈方法，也可以用数组方括号索引的方法。
* 队列方法

    队列数据结构的访问规则是先进先出，在末尾添加项，在前端移除项，`push()`方法可以向数组末尾添加项，`shift()`可以移除数组中的第一个项并返回改项，同时长度减一，结合使用`shift()`和`push()`可以使数组像队列一样
    
    还有一个和`shift()`用途相反的方法`unshift()`，它能在数组前端添加任意项并返回这个新数组的长度，同时使用`unshift()`和`pop()可以从相反的方向来模拟队列
    
    > 注意：给数组添加项的方法它的参数可以是任意多的，返回的是数组的长度，移除数组项的方法不带参数，移除一个项，返回的是移除的项

* 重排序方法

    关于数组的顺序有两个方法可以改变`reverse()`和`sort()`，前者能反转数组项的顺序，后者可以按照升序排列数组项，但是这个方法会调用数组项的`toString()`转型方法，然后比较得到的字符串，但是字符串的先后顺序和数值不一样，所以不会得到理想的结果，所以需要给`sort()`传一个比较函数作为参数，比较函数接收两个参数，如果第一个参数应该位于第二个参数之前，则返回负数，如果两个参数相等，则返回0，如果第一个参数应该位于第二个参数之后返回正数。在比较函数传递到`sort()`之后，数值仍然保持正确地升序。两个方法都返回排序之后的数组
    
* 操作方法

    `concat()`连接数组，返回新数组；`slice()`可以截取数组指定的一段，并返回新的数组，它不会影响原始数组，截取的起始位置是第一个参数，结束位置是第二个参数；`splice()`主要用途是向数组中部插入项，接收三个参数，第一个参数是操作项的位置索引，第二个参数是项数，第三个参数可选，是插入的项，它始终都是返回一个数组，该数组中包含原生数组中删除的项，这个方法会改变原始数组。
* 位置方法

    `indexOf()`和`lastIndexOf()`，这两个方法都接收两个参数：要查找的项和查找起点位置的索引（可选），其中前者从数组的开头向后查找，后者从数组的末尾向前开始查找，两个方法都返回要查找的项在数组中的位置，在没有找到的情况下，返回-1
* 迭代方法

    共有五个迭代方法，每个方法都接收两个参数：要在每一项上运行的函数和运行该函数的作用域对象（这个会影响`this`的值，是可选的），传入这些方法中的函数会接收三个参数：数组项的值、该项在数组中的位置和数组对象本身。以下是五个迭代方法的作用：`every()`:对数组中的每一项运行给定函数，如果该函数对每一项都返回`true`，则返回`true`；`filter()`对数组中的每一项运行给定函数，返回该函数会返回`true`的项组成的数组（筛选作用）；`forEach()`对数组中的每一项运行给定函数，这个方法没有返回值；`map()`对数组中的每一项运行给定函数，返回每次函数调用结果组成的数组；`some()`对数组中的每一项运行给定函数，如果这个函数对任一项返回`true`则返回`true`，以上方法都不会修改数组中的值
* 归并方法

    两个归并方法`reduce()`和`reduceRight()`这两个方法都会迭代数组的所有项，然后构建一个最终返回的值，其中前者从数组的第一项开始，逐个遍历到最后，而后者则从数组的最后一项开始，向前遍历到第一项。这两个方法都接收两个参数：一个在每一项上调用的函数和作为归并基础的初始值（可选），传入的函数接受四个参数：前一个值，当前值，项的索引和数组对象，这个函数返回的任何值都会作为第一个参数自动传给下一项
    ```js
    var values = [1,2,3,4,5];
    var sum = values.reduce(function(prev, cur, index, array){
        return prev + cur;
    });
    console.log(sum); //15
    ```
    
#### 3. Date类型

要创建一个日期对象，使用`new`操作符和`Date`构造函数即可
```js
var now = new Date();
```
在调用`Date`构造函数而不传参数的情况下，新创建的对象自动获得当前日期和时间，如果想根据特定的日期创建日期对象，可以传入表示该日期的毫秒数（从1970年1月1日午夜至该日期经过的毫秒数），为了简化这一计算过程，有两个方法：`Date.parse()`和`Date.UTC()`，前者接收一个表示日期的字符串参数，然后尝试根据这个字符串返回相应日期的毫秒数，它接收的日期的格式也是特定的，否则会返回`NaN`，构造函数也可以传入特定格式的日期字符串，如下图所示

![](http://p4k6er8dp.bkt.clouddn.com/18-10-11/99829634.jpg)

`Date.UTC()`方法同样返回表示日期的毫秒数，但是它与`Date.parse()`在构建时使用不同的信息，`Date.UTC()`的参数分别是年份、基于0开始的月份、月中的哪一天、小时数、分钟、秒以及毫秒数，前两个参数是必须的，以下是两种方法示例
```js
var someDate = new Date(Date.parse("May 25, 2004"));
var y2k = new Date(Date.UTC(2000,0));
```
除此之外，`Date.now()`方法也可以返回调用这个方法时的日期和时间的毫秒数（就是现在，不能传参数），也可以使用`+`把`Date`对象转换成字符串
```js
var start = Date.now();
```
* 继承的方法

    与其他引用类型一样，`Date`类型也重写了`toLocaleString()`,`toString()`和`valueOf()`但是这些方法分返回值与其他类型中的方法不同，这些方法会将`Date`引用类型转换成字符串或数值，不同的方法转换的字符串格式不同。另外当日期使用加减比较大小等此类数值操作，它能够自动调用`valueOf()`方法转换成毫秒数（数值）
* 日期格式化方法

    `Date`类型还有一些专门用于将日期格式化为字符串的方法:`toDateString()`,`toTimeString()`,`toLocaleDateString()`,`toLocaleTimeString()`,`toUTCString()`，这些方法都是转换成标准类型的字符串，具体如下图所示：
    
    ![image](http://p4k6er8dp.bkt.clouddn.com/7B9E4B79-C9E7-4CDE-8969-E04B97DEFE64.png)
    
* 日期、时间组件方法

    以下都是直接取得和设置日期中特定部分的方法，注意，`UTC`日期指的是在没有时区偏差的情况下(将日期转换为`GMT`时间) 的日期值
    ![](http://p4k6er8dp.bkt.clouddn.com/F6EB38D2-0E74-4966-9011-586D14816EAD.png)
    ![](http://p4k6er8dp.bkt.clouddn.com/6147BBA1-54BF-4B89-9312-468689D235AC.png)

#### 4. ReggExp类型
正则表达式的基本结构如下：
```js
var expression = / pattern / flags ;
```
其中`pattern`部分可以是简单或复杂的正则表达式，`flags`部分是一个或多个标志，正则表达式的匹配模式支持三个标志，`g`（全局模式）,`i`（不区分大小写模式）,`m`（多行模式）。另一种创建正则表达式的方式是使用`RegExp`构造函数，它接收两个参数：一个是要匹配的字符串模式，另一个是可选的标志字符串，可以使用字面量定义的任何表达式，都可以使用构造函数来定义
```js
var pattern = new RegExp("[bc]at","i");
```
使用正则表达式字面量和使用构造函数创建的正则表达式不一样，正则表达式始终会共享同一个`RegExp`实例，而构造函数创建的每一个新`RegExp`实例都是一个新实例

* RegExp实例属性

    `global`是布尔值，表示是否设置了`g`标志；`ignoreCase`布尔值，表示是否设置了`i`标志，`lastIndex`整数，表示开始搜索下一个匹配项的字符位置，从`0`算起；`multiline`布尔值，表示是否设置了`m`标志；`source`正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。
    
* RegExp实例方法

    主要方法是`exec()`，该方法专门为捕获组而设计，接受一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组。返回的数组包括两个额外的属性，`index`和`input`，其中前者表示匹配项在字符串中的位置，后者表示应用正则表达式的字符串。数组的第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串。全局标志`g`会改变每次匹配之后的`lastIndex`属性，并且返回的匹配项也不同
    
    第二个方法是`test()`，它接受一个字符串参数，返回值是布尔值，匹配成功返回`true`否则返回`false`，经常用在`if`语句中。
    
    正则表达式实例继承`toLocalString()`和`toString()`方法，返回正则表达式的字面量，与创建正则表达式的方式无关
* RegExp构造函数属性

    `RegExp`构造函数包含一些属性，这些属性适用于作用域中的所有的正则表达式，基于所执行的最近一次正则表达式操作而变化，具体属性如下图所示
    
    ![](http://p4k6er8dp.bkt.clouddn.com/7E6F112C-4012-4865-9726-E745F670A8E1.png)
    
    这些属性可以从`test()`和`exec()`中提取信息即使`test()`方法返回的是一个布尔值，但是这些属性也会被匹配相应捕获组的字符串自动填充
* 模式的局限性
    正则表达式仍然缺少某些语言所支持的高级正则表达式特性，如下所示：匹配字符串开始和结尾的`\A`和`\Z`锚（但是有`^`和`$`来匹配开始和结尾）；向后查找；并集和交集；原子组；`Unicode`支持；命的捕获组（但是有编号）；条件匹配；正则表达式注释

#### 5. Function类型

函数实际上是对象，每个函数都是`Function`类型的实例，而且具有属性和方法，由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定，函数可以用以下方法声明
```js
function sum () { //函数声明语法
    return num1 + num2;
}
var sum = function (num1, num2) {//定义变量sum并将其初始化为一个函数，通过变量sum就可以引用函数
    return num1 + num2;
};//注意这里有一个分号，就像声明其他变量一样
var sum = new Function ("num1","num2","return num1 + num2");
//Function构造函数接收任意数量的参数，但是最后一个参数始终都被看成函数体，而前面的参数枚举了新函数的参数，但是考虑性能问题一般不采用此方法
```
由于函数名仅仅是指指向函数的指针，因此函数名与包含对象指针的变量没有区别，因此一个函数可能会有多个名字
```js
function sum(num1, num2){
    return num1 + num2;
}
alert(sum(10,10));        //20
var anotherSum = sum;//这里是赋值不是调用函数
alert(anotherSum(10,10)); //20
sum = null;//这里让sum与函数断绝关系，但是仍然可以使用anotherSum
alert(anotherSum(10,10)); //20
```
* 没有重载

    在创建第二个函数时，实际上覆盖了引用第一个函数的变量，因此函数没有重载
* 函数声明与函数表达式

    函数声明不同于函数函数表达式，因为解析器在执行环境中加载数据时，会率先读取函数声明，并且使其在执行任何代码之前；但是函数表达式必须等解析器执行到它所在的代码行，才会真正被解释执行
    ```js
    alert(sum(10,10));
    function sum(num1, num2){
        return num1 + num2;
    }
    //////////////////////////
    alert(sum(10,10));
    var sum = function(num1, num2){
        return num1 + num2;
    };
    ```
    以上代码中第一个例子可以正常运行，因为代码执行之前，解析器已经通过一个名为函数声明提升的过程，读取并将函数声明添加到执行环境中。对代码求值时，`js`引擎在第一遍会声明函数并将它们放到代码叔的顶部，即便函数声明在调用函数的代码之后，函数声明也能被提升到顶部。但是第二个例子就会出现错误，原因在于函数位于一个初始化语句中而不是一个函数声明。
    
* 作为值的函数

    函数本身就是变量，所以函数可以作为值来使用，不仅可以像传递参数一样把函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回。
* 函数内部属性

    函数有两个特殊对象`arguments`和`this`，`arguments`是一个类数组对象，包含传入函数中的所有参数，虽然它的主要用途是保存函数参数，但是这个对象还有一个名叫`callee`的属性，这个属性是一个指针，指向拥有`arguments`对象的函数。这个用途可以消除函数执行与函数名的紧密耦合的现象
    ```js
    function factorial(num){
        if(num <=1) {
            return 1;
        }else {
            return num * factorial(num-1)
        }
    }
    /////////////////////
    function factorial(num){
        if(num <=1) {
            return 1;
        }else {
            return num * arguments.callee(num-1)
        }
    }
    ```
    以上例子中修改之后的写法在函数体内部没有再引用函数名，这样无论引用函数时使用的什么名字，都可以完成递归调用。
    
    函数内部的另一个特殊对象是`this`，`this`引用的是函数据以执行的环境对象——或者也可以说是`this`值。
    
    函数对象还有一个属性`caller`，这个属性中保存着调用当前函数的函数的引用，如果是在全局作用域中调用当前函数，它的值为`null`
* 函数属性和方法

    每个函数都有两个属性`length`和`prototype`，`length`表示函数希望接收的命名参数的个数。对于引用类型而言，`prototype`是保存它们所有实例方法的真正所在。在创建自定义引用类型以及实现继承时，`prototype`属性的作用极其重要。
    
    每个函数包含两个非继承而来的方法`apply()`和`call()`，这两个方法的用途是在特定的作用域中调用函数，实际上等于设置函数体内`this`对象的值。`apply()`方法接收两个参数，一个是在其中运行函数的作用域，另一个是参数数组。这个数组可以是`Array`实例也可以是`arguments`对象
    
    `call()`方法与`apply()`方法作用相同，区别仅在于接收参数的方式不同，对于`call()`方法而言，第一个参数是`this`值没有变化，变化的是其余参数都直接传递给函数，而不是数组。
    
    事实上传递参数并非`apply()`和`call()`真正的用武之地，它们强大的地方是能够扩充函数赖以运行的作用域。还有一个方法`bind()`这个方法会创建一个函数的实例，其`this`值会被绑定到传给`bind()`函数的值
    ```js
    window.color = "red";
    var o = {color:"blue};
    function sayColor () {
        alert(this.color);
    }
    var objectSayColor = sayColor.bind(o);
    objectSayColor();//blue
    ```
    `sayColor()`调用`bind()`并传入对象`o`,创建了`objectSayColor()`函数。`objectSayColor()`函数的`this`值等于`o`，因此即使是在全局作用域中调用这个函数，也会看到`blue`。

#### 6. 基本包装类型
为了便于操作基本类型值，`ECMAScript`还提供了3个特殊的引用类型，`Boolean`类型，`Number`和`String`，这些类型和其他引用类型相似但是也同时具有各自基本类型相应的特殊行为。实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据
```js
var s1 = "some text";
var s2 = s1.substring(2);
```
在以上例子中，基本类型不是对象，因此不应该具有方法，为了能够这么操作，后台进行了一系列处理，首先创建`String`类型的一个实例，然后再实例上调用指定方法，最后销毁这个实例，经过此番处理之后，基本的字符串值就会变得跟对象一样了。以上步骤也适用于布尔类型和数字类型。

引用类型与基本包装类型的主要区别就是对象的生存期，使用`new`操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中，而自动创建的基本包装类型的对象，只存在于一行代码执行的瞬间，然后立即销毁，因此我们不能再运行时为基本类型值添加属性和方法。

当然也可以显式调用`Boolean`，`Number`和`String`来创建基本包装类型。对基本包装类型的实例调用`typeof()`会返回`objec`，而且所有基本包装类型的对象都会转换为布尔值`true`
```js
var obj = new Object("some text");//在这里传入的是字符串，就会创建字符串实例，传入的是数值就会得到Number实例，传入布尔值参数就会得到Boolean实例
alert(obj instanceof String); //true
```
* Boolean类型

    布尔类型的实例重写了`valueOf()`和`toString()`方法，布尔类型与布尔值对应的引用类型有两个地方不同。第一个不同就是无论给布尔构造函数传入的是`true`还是`false`，布尔表达式中的所有对象都会被转回为`true`；第二个不同在于`typeof`操作符对基本类型返回`boolean`但是对引用类型返回`object`。`instanceof`操作符测试`Boolean`对象会返回`true`，而测试基本类型会返回`false`
* Number类型

    `Number`类型重写了如下方法：`valueOf()`,`toLoaleString()`和`toString()`，`valueOf()`方法返回对象表示的基本类型的值，另外两个方法返回字符串形式的值。`toString()`方法还可以传递一个表示基数的参数，告诉它返回几进制的字符串形式。`toFixed()`方法会按照指定的小数位返回数值的字符串表示,传入的参数是多少，小数之后就有多少位，并且可以四舍五入。`toExponential()`该方法返回指数表示法，表示的数值的字符串形式，并且可以接受参数，这个参数指定输出结果中的小数位数。`toPrecision()`方法可能返回固定大小的格式，也可能返回指数格式，具体规则是看哪种格式更合适，这个方法接收一个参数，即表示数值的所有数字的位数。`toPrecision()`会根据处理的数值决定到底调用` toFixed()`还是`toExponential()`这三个方法都可以通过向上或向下舍入
    ```js
    var num = 99;
    alert(num.toPrecision(1)); //"1e+2" 
    alert(num.toPrecision(2)); //"99" 
    alert(num.toPrecision(3)); //"99.0"
    ```
* String类型

    字符串类型的对象包装类型，有`valueOf()`，`toLocaleString()`和`toString()`，同时每个实例都有一个`length`属性，表示字符串中包含多个字符。除此之外还有很多方法，用以辅助完成对`ECMAScript`中字符串的解析和操作
    
    * `charAt()`和`charCodeAt()`//返回给定位置的字符或字符编码
    * `conact()`,`slice()`,`substr()`,`substring()`//字符串操作
    * `indexOf()`,`lastIndexOf()`//搜索
    * `match()`，`search()`，`replace()`,`split()`//模式匹配
    * `localeCompare()`//两个字符串比较
    * `fromCharCode()`//接收字符编码返回字符
    * `HTML`//方法，如下图所示，但是不建议使用
    
    ![](https://ws1.sinaimg.cn/large/006XqmrNly1fwh0uklkx2j30ya0b4q4n.jpg)

#### 7. 单体内置对象
* Global对象

    不管从什么角度看，这个对象都是不存在的，`Global`对象在某种意义上说是一个终极的兜底对象，换句话说，不属于任何其他的属性和方法，最终都是它的属性和方法。事实上，没有全局变量或全局函数；所有在全局作用域中定义的属性和函数都是`Global`对象的属性
    
    * **URI编码方法**：`Global`对象的`encodeURI()`和`encodeURIComponent()`方法可以对`URI(Uniform Resource Identifiers)`（通用资源标识符）进行编码以便发给浏览器。有效的`URI`不能包含某些字符，例如空格。以上两个方法有如下区别，前者主要用于整个`URI`,而且能对除空格以外的特殊字符编码,而后者主要用于对`URI`中的某一段进行编码。`encodeURI()`和`encodeURIComponent()`方法对应的两个方法分别是`decodeURI()`和`decodeURIComponent()`其中，前者只能对`encodeURI()`替换的字符（只有空格）进行解码，`decodeURIComponent()`能够解码使用`encodeURIComponent()`编码的所有字符（即所有字符
    * **eval()方法(避免使用这个语法)**：`eval()`方法就像一个完整的`ECMAScript`解析器，它只能接受一个参数，即要执行的`ECMAScript`(或`JavaScript`)字符串。当解析器发现代码中调用`eval()`方法时，它会将传入的参数当作实际的`ECMAScript`语句来解析，然后把执行结果插入到原位置,通过`eval()`执行的代码被认为是包含该次调用的执行环境的一部分，因此被执行的代码具有与该执行环境相同的作用域链。这意味着通过`eval()`执行的代码可以引用在包 含环境中定义的变量
    * **Global对象的属性**：下表列出了`Global`对象的所有属性
    
    ![](https://ws1.sinaimg.cn/large/006XqmrNly1fwhzijuf7wj30x40b4q4x.jpg)
    
    `ECMAScript5`明确禁止给`undefined`、`NaN`和`Infinity`赋值
    * **window对象**：在`Web`浏览器中将`Window`对象作为全局对象。所以全局作用域中声明的所有变量和属性都是`Window`对象的属性

* Math对象
 
    为保存数学公式和信息提供了一个公共位置，即`Math`对象，它提供的计算功能执行起来很快，它还提供了辅助完成这些计算方法的属性和方法

    * **Math对象的属性**：`Math`对象包含的属性都是数学计算中可能会用到的一些特殊值，下表列出了这些属性：
    
    ![](https://ws1.sinaimg.cn/large/006XqmrNly1fwhztjhn76j30ws0aytaa.jpg)
    
    * **min()和max()方法**：这两个方法可以接收任意多个数值参数，用于确定一组数值中的最大值和最小值
    * **舍入方法**：将小数值舍入为整数的几个方法如下：`Math.ceil()`，`Math.floor()`,`Math.round()`,分别遵循如下规则：向上舍入和向下舍入和标准舍入（四舍五入）
    * **random()方法**：`Math.random()`方法返回大于等于0小于1的一个随机数，套用如下公式可以在某个范围随机选择一个值`值 = Math.floor(Math.random() * 可能值的总数 + 第一个可能的值)`,因为`Math.random()`总会返回一个小数值，所以需要用`Math.floor`方法
    * **其他方法**:`Math`对象中还包含其它一些有关计算的方法，以下是`Math`对象其它方法
    
    ![](https://ws1.sinaimg.cn/large/006XqmrNly1fwi6c3mz23j30xa07umyu.jpg)
        
## 问题
1. 加标签的label语句没看懂有什么用
2. 如何理解函数参数是按值传递的
3. 没有看懂引用计数
4. 正则表达式构造函数和字面量创建对象的区别没有看懂
5. 这两个例子中this有什么区别吗，这个this到底指的是什么![](http://p4k6er8dp.bkt.clouddn.com/58A8B7A5-AACC-493F-B0E3-EFC2C1F4EE54.png)
6. apply()方法 ![](https://ws1.sinaimg.cn/large/006XqmrNly1fwi00kc7gfj30yg04ot9t.jpg)