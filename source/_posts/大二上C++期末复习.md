---
title: C++期末复习总结
---


### 知识点归纳
1. 面向对象技术的核心概念：数据封装（抽象）、继承、多态、泛型编程
2. 枚举类型：enum 枚举类型名 { 枚举常亮标识符列表}；
3. const 作用于指针：
* const int*p：就是指针本身是这个改变的，可以指向其他地址，但是此时 指向的这个单元是不可改的；
* int * const p->这个指针是一个常量，不能再指向别的单元，但是p指向的内容是一个变量；
* const int * const p->指向常量的常亮指针
4. 空指针类型   nullptr
5. 引用中的注意事项：
* 不存在void&类型的引用，但是void*是合法的；
* 不能创建引用数组，但是int * arr[10]是正确的；
* 引用也存在内存重解释的问题
6. 指向数组元素的指针：数组的名字就是一个指针常量，这个指针指向的是数组的首元素
```
int a[10];
int *p;
p = a;
int *q;
q = &a[0];
```
7. 指向数组的指针：这个指针指向的是整个数组,称为“数组指针”
```
int a[10];
int (*p)[10];
p = &a;
```
以上表示的是数组中每个元素都是int
```
int *p[10]
```
以上表示的是指针数组，首先p是一个数组，里面的内容是int* 类型的
8. 特殊的运算符
* sizeof:计算类型或其变量在内存中所占字节数的运算符
* new:自动计算要分配类型的字节数，自动返回正确的指针类型,可以给分配的空间初始化
* typeid:获取对象的类型信息
9. 类型自动推导：decltype——decltype(e)o,e如果没有别括号包围，o就是e的类型，e如果是一个函数调用，o是函数返回值类型，否则o就是一个引用，和e同类型；auto——auto x = y;y是什么类型,x就是什么类型，但是在这之前x必须被初始化；lambda表达式——是一种轻量级的函数
10. 函数原型函数类型
11. 参数结合的三种方式：值、指针、引用
12. 函数的返回类型：返回值、返回指针、返回引用
13. 构造函数列表：直接初始化的方式初始化列表中的成员必须是类的直接成员，非成员和继承的基类成员不能出现在初始化列表中。类中的常量，独立引用等特殊成员只能在初始化列表中
14. 复制构造函数：为什么需要复制构造函数——在形参于实参结合的过程中，就是一种复制，如果没有复制构造函数的话，会自动复制，但是自动复制的后果就是原有的构造函数不会被复制，而是用的编译器自己合成的构造函数，这样就不能实现原有的构造函数的作用，因此需要复制构造函数去阻止编译器的这中行为。复制构造函数的参数不能为值参数，为了避免反复调用复制构造函数。那么什么时候会调用复制构造函数——显式定义复制对象时候；实参于形参结合时候；函数的返回值对象不是指针和引用的时候。
15. 运算符重载：单目运算符作为成员函数重载，双目运算符作为友元函数重载，重载的运算符函数不能是静态成员
16. 可调用对象：函数、lambda表达式、重载了()运算符的类对象
17. 在继承链中，构造函数的调用顺序是父类到子类，析构函数正好相反。不能被继承的有构造函数，析构函数，运算符重载。
18. 虚函数和多态：父类中的函数前加virtual表示这个函数是可以被覆盖的。虚特性是可以被继承的，在继承链中，一旦基类中的某个函数是虚的，那么其所有后代的所有原型相同的函数都是虚的。虚析构函数为的是能够调用子类的析构函数
19. override与final：override表明这个函数是用于覆盖的，final表明这个函数是覆盖的最终版本，不能再被其他函数覆盖
20. 纯虚函数，是一个蓝本，是不能被实现的，其对类成员函数的访问只能用const，只读的形式。一个类至少有一个纯虚函数，那么这个类就是抽象类，抽象类不能被实例化，不能作为函数的参数类型和返回类型，但是抽象类的指针或引用却可以。
21. 模板和泛型编程
22. 容器类和迭代器




### 问题
1. void*和int * arr[10]是什么意思
2. 异常处理
3. 内联函数
4. ？的意思