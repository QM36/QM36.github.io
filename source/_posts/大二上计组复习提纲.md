---
title: 大二上计组复习总结
---


## 第一章
#### 1. 冯·诺依曼体系
1. 用二进制代码表示程序和数据
2. 计算机采用存储程序的工作方式：
将程序指令和数据存储起来(存储程序),让计算机自动地执行指令,完成各种复杂的运算操作(称为程序控制)
3. 计算机硬件由存储器、运算器、控制器、输入设备和输出设备组成

#### 2. 多机系统结构
根据处理器之间连接的紧密程度
1. 紧密耦合系统：多个（CPU+LM）组，通过系统总线构成多机系统，共享全局M
2. 松散耦合系统:多个节点，由通信接口CAS并通过MTS构成多机系统

#### 3.语言处理程序几个名词概念
1. 翻译程序：指把高级语言源程序翻译成机器语言程序（目标代码）的软件。（分为编译程序和解释程序）
2. 编译程序：将高级语言一次翻译成目标程序，每次执行程序的时候，只执行目标程序。
3. 解释程序：将源程序的一条语句翻译成目标代码，并立即执行，然后翻译下一条语句…,直至执行完最后一条语句。程序的执行过程中，不能脱离源程序和解释程序。
4. 汇编程序：将汇编语言的源程序编译成机器语言程序。
5. 编程语言分类：
* 机器语言：二进制代码0/1表示机器指令。
* 汇编语言：用助记符按规定格式表示各种机器指令。汇编语言的源程序必须经过汇编程序的编译，将其转换为机器语言后才能被机器执行。
* 高级语言：用类似自然语言的符号表示各种指令。通常高级语言需要经过**编译程序**编译成汇编语言程序，然后再通过**汇编程序**编译成机器语言。或者有解释程序翻译成机器语言。

#### 4. 计算机系统的性能指标
1. 基本字长：指一次操作的基本位数。
它影响计算精度、指令功能。
2. 外频：外部频率或基频，也叫系统时钟频率
3. 运算速度：
* （1）CPU主频=外频×倍频系数；
* （2）IPS，每秒执行指令数；
* （3）CPI，即Clock-cycle Per Instruction ；
* （4）FLOPS，每秒执行浮点运算的次数；
4. 数据传输率：单位时间的数据传输量（比特每秒bit/s）
5. 存储容量

#### 5. 存储程序的工作方式
1. 事先编制程序
2. 事先存储程序
3. 自动、连续的执行程序
4. 输出结果

#### 6.机器字长、存储字长、指令字长的区别于联系
1. 机器字长：计算机直接处理的二进制数据位数，**机器字长等于寄存器的大小**，他决定计算机运算精度。
2. 存储字长：一个**存储单元**中包含的**二进制代码的位数**。
3. 指令字长：一条**指令**中包含的二进制代码的位数。
4. ==指令字长一般是存储字长的整数倍，如果指令字长等于存储字长的2倍，需要2次访存来取出指令，因此，取指周期是机器周期的2倍。==
## 第二章
#### 1. 进制转换
1. 十进制转换为二进制：整数部分，除以2取余数（从下到上）；小数部分，乘2取整（从上到下）
2. 二进制转换为十进制：无论小数还是整数，都是按权位相加
3. 二进制扎转换为十六进制：四位为一个整体，整数部分前面补0，小数部分后面补0。
4. 十六进制转换为二进制：将一位扩展成四位，整数与小数一样
5. 十进制与十六进制转换通过二进制

#### 2. 数的符号表示
1. 真值：把正负号和绝对值一起表示的数值
2. 机器数：连同符号一起数字化的数，分为原码、补码和反码
3. 原码：最高位是符号位，其余数值不变，0正1负
* [+0] = 00000000  [-0] = 10000000
* 8位原码表示范围：+127~-127   [+127] = 01111111  [-127] = 11111111
4. 反码：正数的反码等于原码，负数的反码，符号位不变，其余各位按位取反
* [+0] = 00000000 [-0] = 11111111
* 8位反码表示范围：+127~-127
[+127] = 01111111  [-127] = 10000000
5. 补码：正数的补码等于原码，负数的补码符号位不变，其余按位取反，末尾+1，即反码加1
* [+0]补=[-0]补= 0 0000000
* 8位补码，表示范围为：+127～-128
即：
		[+127]补=0 1111111；
		[-128]补 =1 0000000
* 【注意】8位补码可以比原码、反码多表示一个负数，即-128
6. 补码的补码就是原码

#### 3. 定点数与浮点数
1. 定点数分为无符号数，定点整数和定点小数
2. 浮点数的表示为：阶符 阶码位（带符号的定点整数） 数符 尾数位（带符号的定点小数）
* 阶码底：隐含约定为2；
* 阶码：补码或移码表示，位数决定数值范围
* 尾数：原码或补码表示，位数决定数的精度
3. 尾数规格化：
* 原码：1/2 <= |M| < 1
* 补码：-1 < M <= -1/2  1/2 <= M < 1

#### 4. 移码
1. 若阶码数值部分为5位,以ｘ表示真值，则
　　 [ｘ]移＝25＋ｘ 　25＞ｘ≥－ 25 
2. 移码的表示范围和补码一致，0只有一种表示方式，只是符号位正好相反。
3. 正数的移码是符号位变反
4. 负数的移码连同符号位一起变反之后加1

#### 5. IEEE754 的标准：
1. 表示格式
![](http://oczira72b.bkt.clouddn.com/17-12-28/12220652.jpg)
2. 注意：
* 尾数用纯小数表示，原码，真值=1+M
* 阶码，阶符隐含，采用移码方式表示，但只偏移2n-1 
3. 总结：
![](http://oczira72b.bkt.clouddn.com/17-12-28/35399517.jpg)
4. 几点注释：
* 为了确保浮点数的唯一性，约定0≤M<1
* 浮点数所表示的范围比定点数大
* E全0，M全0时，F=0；E全1，M全0时，F为±∞；E全1，M非全0时，F为无效数(NAN)；

#### 6.指令的信息表示
1. 指令格式：操作码加操作数（地址码/寄存器/立即数）
2. 操作码格式：分为定长操作码和变长操作码
* 定长：所有指令操作码的位置位数固定。便于操作译码，译码与取并行；一般用于指令字较长的指令
* 变长：操作码位置位数不固定，按需求变化。从而可以更有效的利用存储空间。边长操作码的两种方式：扩展操作码、复合操作码
* 扩展操作码：在指令字较短的情况下，利用某些指令地址位数较少产生的空闲位，来扩展操作码。关键在设置扩展标志
* 操作码采用方式码编码，每个部分表示一种操作
3. 指令提供地址的方式：
* 显地址方式：指令中明显指明地址
* 隐地址方式：地址隐含约定，不出现在指令中，可以减少指令中地址数，简化地址结构
* 地址结构的简化：四地址指令、三地址指令、二地址指令、一地址指令（双操作数、单操作数）、；0地址指令（单操作数、不需要操作数）
* 寻址方式：寻找操作数地址或操作数的方式。CPU能直接访问的操作数只能在==主存==或==CPU内的寄存器==。寻址方式分为四种：立即寻址、直接寻址、间接寻址、变址类寻址
* 立即寻址：助记符 I。分为定长格式（操作数在指令中，长度固定、有限）和变长格式（操作数在基本指令之后，长度可变）。用于提供常数、设置初值，速度快但是灵活性差
* 直接寻址：直接给出操作数的地址（存储单元号或寄存器号），分为存储器直接寻址（A），和寄存器直接寻址(R),R所占位数少，访问比M快
* 间接寻址：操作数在M中，但是间接给出存储单元号和寄存器号，分为存储器间址（@）和寄存器间址（（R）），存储器简址需要两次访存，寄存器间址指针内容可变，使同一指令可指向不同存储单元，以实现程序的循环、共享，并提供转移地址
* 自增寄存器间接寻址（（R）+）：从寄存器中读取操作数地址，寄存器内容+1
* 自减型寄存器间接寻址（-(R)）：寄存器内容减1作为操作数地址，按此地址访问存储器
* 堆栈寻址：操作数在堆栈中，指令中由SP间接提供操作数地址（或隐含约定为SP）分为自减型间址（-（SP））和自增型间址（（SP）+）,==自减就是压栈，自增就是出栈==，因为栈底的数字大，栈顶的数字小
* 变址寻址（X(R)：指令给出一个寄存器号和一个地址量，寄存器内容与地址量之和为操作数有效地址（一维数组读写），有效地址是修改量加基准地址，修改量是变址寄存器号，基准地址是形式地址，基准地址不变，只变寄存器号
* 基址寻址：指令给出一个寄存器号和一个地址量，寄存器内容与地址量之和为有效地址，有效地址是基址寄存器号加位移量，位移量就是相对于基址的位移，这是不可变的，基准量是寄存器号，这是可变的
* 基址加变址寻址：指令给出两个寄存器号和一个地址量，寄存器内容与地址量之和为有效地址，变址寄存器号，基址寄存器号和位移量，便于处理二维数组
* 相对寻址（浮动编址）（X(PC)
）指令给出位移量，PC寄存器的值与位移量之和为有效地址。
* 页面寻址：指令给出位移量，PC的高位部分与位移量拼接，形成有效地址，PC是页号，A是页内地址
* ==注意：== 
* * 操作码隐含说明寻址方式不同
* * 指令中设置专门字段说明寻址方式

#### 7. 指令类型
##### 按照指令功能分类
1. 传送指令：源地址指向目的地址，设置时需要考虑传送范围，指明传送单位（一次传送的数据位数8、16、32）
2. ==输入/输出指令==：主机与外设之间各种信息的传递，设置时需要考虑==IO指令的功能扩展==（IO指令中留有扩展余地，某些字段编码事先不定义，需要时再约定其含义，用于外设种类、数量不多的场合；IO接口中设置控制/状态寄存器）==主机对外设的寻址方式==（寻找IO接口中的寄存器的方式）具体如下：
* 单独编址：编址到寄存器：为每个寄存器（IO端口）分配独立的端口地址；IO指令中给出端口地址。IO地址空间不占主存空间，可与主存空间叠加，需设置标志区分访问对象
* 统一编址：编址到寄存器，为每个寄存器（IO端口）分配总线地址，访问外设时，指令中给出总线地址。IO端口占据部分主存空间，常将存储空间的低端分配给主存，高端分配给IO端口，以示区分。</br>
主存与外设之间的信息传递，设置时还需要考虑==IO指令设置方式==：设置专用IO指令——显式IO指令，针对单独编址，用IO指令访问IO端口。指令中说明输入输出操作，并给出端口地址；用传送指令实现IO操作——隐式IO指令，针对统一编址，用传送指令访问IO端口，不设专用IO指令。
3. 算数逻辑运算指令：
* 算数运算指令：设置时需考虑操作数类型、符号、进制等，运算结束后设置相应状态标志
* 逻辑运算指令：实现代码位的设置、测试、清除、修改等
4. 程序控制指令：
* 转移指令：无条件转移（操作码+转移地址）条件转移（操作码+转移地址+转移条件）循环（转移条件位循环计数值）
* 转子指令与返回指令（转子：操作码+子程序入口）（返回：操作码），同一条返回指令应该提供多个不同的返回地址。返回地址的存取：用堆栈存放返回地址
* 软中断指令：早期主要用于程序调试，现在常用于系统功能调用，以INT n 的形式出现再程序中，n表示不同的功能调用
* 控制指令：清除进位标志，空操作指令，暂停指令

##### 按指令格式分类：双操作数、单操作数、程序转移指令
##### 按照寻址方式分类：RR\RS\SI\SS

==例题总结：==
1. 按字编址与按字节编址不一样：字节编址就是一个字是8位，按字编址根据计算机的不同来看，有的计算机是16位，则一字是16位，两个字节；有的计算机是64位，就是8字节，即一字等于8个字节

## 第三章 CPU系统
#### 1. CPU的基本组成
1. 运算部件：输入逻辑、输出逻辑、运算逻辑部件
2. 寄存器组：CPU内部需要若干寄存器来存放需要加工、运算的数据、中间结果、最终结果等。
* 寄存器的两种基本组成：独立结构的寄存器、小型RAM（每一个单元作为一个寄存器使用）
* 寄存器分类：按寄存器存放的信息的类型(或使用的方式)进行分类(七类)
3. CPU中寄存器的分类：
* 通用寄存器：通过程序访问，具有多种用途的寄存器，每一个通用寄存器有唯一编号与之对应。作用：存放数据，也可以存放地址进行间接寻址，变址寻址等。标示方法：不同的CPU各不相同
* 暂存器：暂存器不能通过程序访问，也没有编号，主要作用是存放指令执行过程中的中间信息，这些信息对编程者透明
* 指令寄存器（IR）：存放从存储器单元中读出的指令。一个指令寄存器存放一条指令，也可以设置一个指令队列，存放多条指令
* 程序计数器（PC）：用于跟踪程序的地址，PC的初始值为所要执行的程序的首地址。
* 程序状态字寄存器（PSW）：用于记录指令过程中运行的状态和程序的工作方式。主要由两个部分构成：特征位（进位位、溢出位、零标志、正负标志、奇偶标志）和编程设定位（跟踪位：主要用于程序调试；中断允许标志；优先级字段）
* 地址寄存器（MAR）：CPU访问存储器和访问IO端口的地址首先存入MAR，再由MAR送往外部地址总线
* 数据缓冲寄存器（MDR）：用于暂存CPU与存储器和外设之间通信的数据。
4. 控制部件：分时产生微命令，控制计算机完成相应操作从指令执行的角度，指令执行过程是分若干步骤，而每一步又分若干的微操作
5. 时序系统：时序信号分周期、节拍、脉冲等信号。时序系统就是产生时序信号的部件
6. CPU内部的数据通路的结构，分为两种：单总线通路和多总线通路
* 单总线通路：设置一组数据通信总线，所有数据传送均通过该总线进行，结构简单，单不能实现多组数据并发（并行传送）
![](http://oczira72b.bkt.clouddn.com/17-12-29/36115785.jpg)
根据以上特点，有以下数据通路完成相应功能：寄存器到寄存器、运算器到寄存器、寄存器到移位器。这是一种以ALU为中心的单总线结构
* 单组内总线、集成寄存器结构
![](http://oczira72b.bkt.clouddn.com/17-12-29/64334381.jpg)
* 多总线通路：设置多组数据通信总线，可实现不同数据在不同的通路上传送，结构复杂，但能实现多组数据并行传送。
7. 时序控制方式：不同功能、不同速度的部件和设备之间通信时做到时间上的协调，时序控制法就是不同部件和设备通信所采用的时间同步方式（操作与时序信号之间的关系），主要的时序控制方法：同步控制、异步控制、上述方式变形
* 同步控制：各项操作受统一时序控制，统一时序由CPU或其他设备提供，时钟周期作为基本的时序单位，固定不变
![](http://oczira72b.bkt.clouddn.com/17-12-29/87101869.jpg)。特点：有明显的时序时间划分，时钟周期时间固定，各步操作的衔接、各部件之间的数据传送受严格同步时钟定时控制。应用于：CPU内部（CPU工作时，各部件都严格受控制于统一信号，所有部件的动作都要时钟信号触发）、设备内部、系统总线操作
* 异步操作：各项操作按不同需要安排时间，不受统一时序控制。无统一时钟周期划分，各操作间的衔接和部件之间的信息交换采用应答方式，操作流程如下：
![](http://oczira72b.bkt.clouddn.com/17-12-29/69166320.jpg)
应用于：异步总线操作（各部件运算速度差异大、传送时间不确定、传送距离较远）
* 同步方式的变化
1. 不同指令安排不同时钟周期数
2. 总线中插入延长周期
3. 同步方式引入异步应答

#### 2.CPU与外设的信息交换
1. 主机与外设的连接方式：辐射型（不易扩展，线路复杂）、总线型（便于扩展）、通道式（提高并行能力）
2. 信息传送控制方式
* 直接程序传送方式（程序查询方式）：通过指令查询外设工作状态来达到CPU与外设的同步，以实现不同速度设备间的数据的传送
* 中断方式
* 直接存储器存取（DMA）方式：数据传送直接再IO接口与主存器之间

#### 3. 运算部件
1. 并行加法器（并行进位）与串行加法器（串行进位）
2. 分为进位：两级进位，组内并行组间串行或并行
3. 并行进位链：组间并行进位链
4. 运算器组织：
* 向ALU提供操作数的方式：独立R、双口RAM用多路选择器作为ALU的输入逻辑，单口RAM用锁存器作为ALU的输入逻辑。
5. 运算方法：
* 补码加减运算：操作数用补码表示，符号位参与运算，结果用补码表示</br>
==注意：==
1. 求补与变补不一样，变补是不管Y补正负，将其符号位连同尾数一起按位取反，末尾加1
2. 溢出判断：看双符号位是否一样
3. 移位：分逻辑移位（分循环与否）与算数移位（符号位不变）
* 原码/补码一位乘法:原码与补码一位乘法
1. 原码一位乘法
![](http://oczira72b.bkt.clouddn.com/17-12-29/1076684.jpg) </br>
作n次循环（累加右移）
2. 补码一位乘法，用比较法：用相邻两位乘数比较的结果决定+X,-X或+0</br>
![](http://oczira72b.bkt.clouddn.com/17-12-29/15854396.jpg)</br>
==注意==：需要在Y的最后加上0;Y有几位，做几步循环，若需第n+1步，则不移位，仅修正 
* 原码恢复余数法
2乘余数-除数 = 新余数，根据新余数的正负，为正的话够减，商1，为负的话商0，恢复原余数，再乘2
* 原码不恢复余数法：出现不够减时，也可以不恢复余数直接做下一步，改作加除数，结果与恢复余数法等效
* 补码不恢复余数法


#### 4. CPU基本模型
1. 模型机的指令系统
* 指令格式
* 寻址方式
* 指令类型（转子指令、返回指令）
2. 模型机的组成与数据通路
模型机采用：以ALU为中心的总线结构

</br>

![](http://oczira72b.bkt.clouddn.com/17-12-30/10481479.jpg)


</br>
* 暂存器C：从内存中读取的源操作数或源操作数地址，暂存于C中。暂存器D:从内存中读取的目的操作数或目的操作数地址或运行结果暂存于D中
* 选择器A:SP\PC;选择器B：PSW\MDR
* CPU内部总线：采用16条单向数据总线，CPU外部总线（系统总线）：AB\DB\CB均采用同步控制

#### 5. 组合逻辑控制
1. 时序线路：工作脉冲——产生脉冲型微命令，控制定时操作；时钟周期——产生电位型微命令，控制操作时间段
2. 控制器工作过程：取指令、按照寻址方式取数，按照操作码对数据运算处理，示例图：

</br>

![](http://oczira72b.bkt.clouddn.com/17-12-31/35056039.jpg)
</br>
3. 时序控制方式：组合逻辑采用三级时序系统

</br>


![](http://oczira72b.bkt.clouddn.com/17-12-30/15601806.jpg)
</br>
##### 工作周期
* 取指周期：就是取出指令，从M中取出放到IR，然后修改PC的值
* 源周期：按招指令指定的寻址方式，形成源操作数地址并读取源操作数，==将源操作数放在C中==
* 目的周期：按照指令指定的目的的寻址方式，==读取目的地址放在MAR中或者读取目的操作数放在D中==
* 执行周期：完成指令功能，这些功能有传送、运算、取转移地址送入PC、返回地址压栈保存；然后再将后续地址放在MAR中（顺序地址或者转移地址）
* 中断周期：在CPU 响应中断请求之后，直到执行中断服务程序之前的一段时间，关中断，保存断点和PSW，寻找中断服务程序的入口地址并转入中断服务程序（中断周期内的工作由硬件自动完成，非指令完成）
* DMA周期，CPU响应DMA请求后到传送完一次数据，DMA控制器接管总线权，控制直传（此周期内的工作由DMA控制器硬件自动完成）

##### 时钟周期
* 时钟周期长度就是一次访问内存的时间

##### 工作脉冲
* 每个时钟周期结束时设置一个脉冲

4. 指令流程与操作时间表
* 首先是取址周期：M->DB->IR;PC+1->PC
* 再接着是其他周期，但是对于不同指令类型，其他周期的流程不一样，所以分开讲
* 对于传送指令（MOV）:该指令对于不同的寻址方式，有不同的指令流程和操作时间表
* 除此之外还有双操作数单操作数、转移返回指令、转子指令（没有源周期与目的周期），需要会写其操0作流程
* 转移返回指令需要==把转移的地址放进PC\MAR==中,对于堆栈类的寻址需要SP+1，返回指令是转移指令的一种特例，==转移与返回指令的执行周期需要做的事情就是返回需要转移到的地址==
* 转子指令：在ST形成子程序入口;在ET保存返回地址,并转入子程序入口。转子指令也分转子成功与不成功，不成功时分PC型寻址与非PC型寻址。==其执行周期需要做的事情是将返回地址压栈，最后将入口地址送入PC\MAR==
* 最后是中断周期：关中断、修改堆栈指针、保存断点
* 在操作时间表中：==每一节拍都发CPT,工作周期结束发CPT\CPFT\CPST\CPDT\CPFT==;E-为输出，S-为置入，R为读命令
5. ==微命令的综合与产生==

#### 6. 微程序控制方式
1.一条机器指令包含很多微程序，一段微程序包含很多微指令，一条微指令包含很多微命令
2. 模型机的微指令格式：数据通路操作+访存操作+顺序控制
3. 微程序控制的逻辑组成，示例图如下

</br>

![](http://oczira72b.bkt.clouddn.com/17-12-31/94716997.jpg)
</br>
4. 微程序控制的工作方式：取机器指令->转微程序入口->执行首条微指令->取后续微指令->执行后续微指令->返回：微程序执行完，返回CM
5.微指令的一般格式为：微命令字段加地址字段，这样的组合有n组
6. 微指令的编码方式：
* 直接控制法（不译法）：微命令按位给出，1——选用，0——不选用。这样的做法是产生微命令速度快，但是信息的表示率低
，微命令中只有个别位采用直接控制法
* 最短编码法：对微指令命令字段的所有位进行编码，这样的做法是微指令字长最短，但是译码级数较多，需要较多的硬件支持
* 分段直接编译法：一条微指令分为多个微命令字段，每一字段的不同编码表示不同的微命令，即微命令由字段编码给出，这样的做法使得译码器级数少，指令长度短，各字段所表示的微操作可以并行
* 微命令的分组原则：相容性原则（同时执行不会发生冲突）、互斥性原则（串行操作）
* 分段间接编译：微命令由本字段编码和其他字段解释共同给出分为：设置解释位或解释字段和分类编译（按功能类型将微指令分类，分别安排各类微指令格式和字段进行编码，并设置区分标志）
*其他编码方式：微指令译码与机器指令译码复合控制；微地址参与解释
7. 微地址形成方式

##### 形成初始地址：取机器指令和功能转移
* 取指令：所有指令的取指阶段的操作都是相同的，因此将取指所需的所有微操作指令构成一段公共微程序（微子程序），并约定一个公共入口地址，取指阶段结束之后，经过指令译码，再根据指令类型转入不同指令各自对应的微程序段
* 功能转移：按指令功能转入对应的微程序段，分两级功能转移
* 一级功能转移：各操作码的位置（才能方便获得该操作码）、位数（才能获得定长地址码）固定，一次转换成功。但是指令系统中，操作码是连续编码，采用该地址形成方式，形成的微指令地址也是连续的，只能形成一条机器指令所对应的多条微命令的第一条微命令地址，所以需要再次转移
* 二级功能转移（多级转移）：各类操作码位置、位数不固定，需两次转换。有分类转移（用指令类型标志区分操作类型）和功能转移（用指令操作码区分操作类型），转移过程如下：

</br>

![](http://oczira72b.bkt.clouddn.com/17-12-31/7204345.jpg)
</br>

##### 后续地址的形成（增量和断定方式）
* 增量方式：微指令某一字段提供后继地址。顺序（+1），跳步（+2），无条件转移，条件转移，转微子程序，返回微主程序
* 断定方式：由直接给定地址（微指令直接给出后续地址中的某些位）和断定条件（检测某种条件或状态，形成后续的其余位）相结合形成微地址。一般格式为->给定部分（后续微地址高位部分）+断定条件（指明后续微地址低位部分的形成方式）
* 断定方法的变形：将断定依据的代码作为微程序库的地址输入，以该地址读取的单元内容为后继地址
8. 模型机微指令格式
数据通路操作+访存操作+辅助操作（开关中断，置入指令）+顺序控制（形成后续地址的方式）
9. 模型机微程序设计
* 微程序控制器的时序系统：采用同步控制方式，用统一==微指令周期==作为基本时序控制各条微指令执行。微指令周期——从取微指令到微指令执行完成的时间
* 微程序的编制：注意编写顺序、实现转移和多路分支

##### 总结
![](http://oczira72b.bkt.clouddn.com/17-12-31/39514001.jpg)
1. MOV指令有源周期，目的周期，双操作数有源周期和目的周期，单操作数没有源周期，转移返回指令没有源周期与目的周期，转子指令没有目的周期

## 第四章 存储子系统
#### 1.存储系统的层次结构（寄存器、Cache、主存、辅存）访问速度
1. 层次结构

</br>

![](http://oczira72b.bkt.clouddn.com/18-1-2/22612832.jpg)

</br>

2. 访问速度
* 主存：CPU可以直接访问，存放CPU当前使用的指令和数据（能随机访问，工作速度快，容量有限）
* 辅存：存放大量的后备程序和数据（速度较慢，容量大）
* 高速缓冲存储器（Cache）：存放CPU在当前一小段时间内多次使用的程序和数据，以缓解CPU和主存的速度差异（速度很快、容量小）

#### 2. 存储器分类
1. 按照介质分类：
*半导体存储器：利用集成电路工艺制成的存储芯片，分为动态存储器（利用双稳态触发器存储信息：功耗大，速度快、做Cache）和静态存储器（依靠电容上的电荷暂存信息：功耗小，容量小，速度快，适合做主存）
* 磁表面存储器：利用磁层上不同方向的磁化区域表示信息（存储容量大，非破坏性读出，永久保存，读写速度比半导体存储器慢，适合做外存）
* 光盘存储器：利用光斑的有无存储信息（容量大，非破坏性读出、永久保存，速度慢，适合做外存）
2. 按照存取方式分类：
* 随机存取存储器(RAM，ROM)：随机存取——可按地址访问存储器中任一单元,访问时间与单元地址无关。RAM——可读可写，ROM——只读不写
* 顺序存取存储器（SAM）：访问时读写部件按顺序查找目标地址，访问时间与数据位置有关。例如：磁带机。它有两步操作：等待操作和读写操作
* 直接存取存储器（DAM）:访问时读写部件先直接指向一个小区域，再在该区域内顺序查找，访问时间与位置有关，例如：硬盘。它有三步操作：定位/寻道操作，等待/旋转操作，读写操作。

#### 3. 存储系统的性能指标
1. 存取时间：从存储器收到地址到数据写入存储器或者读出的可用的数据为止所需的时间
2. 存取周期：存取时间加上存取间隔
3. 数据传输率
4. SAM的速度指标：平均存取时间，数据传输率
5. DAM的速度指标：平均定位寻道时间，平均等待旋转时间，数据传输率

#### 4. 半导体存储器SRAM\DRAM
1. 静态存储器SRAM(双极型、静态MOS型)：依靠双稳态电路内部交叉反馈机制，功耗较大，速度快，做Cache
* 六管单元
“0”：T1导通，T2截止；“1”：T1截止，T2导通。
“1”：T1截止，T2导通。写1：W高电平、W低电平。
非破坏性读出，读出后不需重写。

</br>

![](http://oczira72b.bkt.clouddn.com/18-1-2/1529476.jpg)

</br>

2. 动态存储器DRAM(动态MOS型)：依靠电容存储电荷的原理存储信息。功耗较小，容量大，速度较快，作主存
* 四管单元

</br>

![](http://oczira72b.bkt.clouddn.com/18-1-2/85088474.jpg)

</br>

“0”：T1导通，T2截止;C1有电荷，C2无电荷）；
“1”：T1截止，T2导通;（C1无电荷，C2有电荷）;
四管单元是非破坏性读出，读出过程即实现刷新


* 单管单元

</br>

![](http://oczira72b.bkt.clouddn.com/18-1-2/95938237.jpg)

</br>

“0”：C无电荷，电平V0（低）;“1”：C有电荷，电平V1（高）;
读出：W先对分布电容C充电预充电，使C的电位Vm (V1+V0)/2，断开充电回路。
单管单元是破坏性读出，读出后需重写。

#### 5. 半导体主存逻辑设计
1. 计算芯片数，一般先扩展位数，再扩展单元数（这里的位数值得是数据线条数）
2. 地址分配与片选逻辑：低位地址分配给芯片，高位地址形成片选逻辑
3. 连接方式：注意地址线和数据线，地址线又分片选和芯片
4. 地址线与片选逻辑的分配方式可以分为全译码，部分译码，线译码
* 全译码：将除了与芯片连接的地址以外的所有高位地址用于译码产生片选信号。电路复杂。
* 部分译码：将除了与芯片连接 的地址以外的部分高位地址用于译码产生片选信号。存储器扩展较难。
* 直接用一条可以区分两组地址范围的地址线的高低电平作为片选信号存储器扩展较难。取决于设计的存储系统的容量
* 采用哪一种译码方式 
5. 芯片分1Kx4和1Kx8,但是其存储容量都是1024b,只是位数不一样
6. 地址大小对应关系

</br>

![](http://oczira72b.bkt.clouddn.com/18-1-2/27732917.jpg)

#### 6. 动态存储器的刷新（集中刷新、分散刷新、异步刷新【DMA请求】）
1. 刷新：定期向电容补充电荷；刷新的原因：电容电荷随时间推移慢慢泄露，需要定期向电容补充电荷。以保持原有信息不变
2. 刷新与重写的区别：刷新——动态存储的芯片，需要补充电荷以保持原信息。重写——破坏性读出后重写，以恢复原来的信息
3. 刷新间隔：2ms；刷新周期：刷新一行所用的时间；刷新周期数：刷新一块芯片所需的周期数，由芯片矩阵的行数决定。
4. 刷新方法：各DRAM芯片同时刷新，片内按行刷新(按行读)
5. 对主存的访问：CPU访存——由CPU提供行、列地址，随机访问；动态芯片刷新——由刷新地址计数器提供行地址，定时刷新。
6. 刷新周期的安排方式：
* 集中刷新（用在实时要求不高的场合。）
* 分散刷新（用在低速系统中）
* 异步刷新（各刷新周期分散安排在2ms内。）

## 第五章 输入输出设备及接口
#### 显示设备
1. CRT显示器结构
2. 屏幕显示与显存(VRAM)的对应关系
3. 显存地址组织:显存单元地址由屏幕显示的行列号决定——行号决定VRAM的高位，列号决定VRAM的低位
4. VRAM(显存)：存放一帧图像对应的相关信息
5. 屏幕显示与显存(VRAM)的对应关系 

</br>

![](http://oczira72b.bkt.clouddn.com/18-1-2/78363694.jpg)

</br>

6. 信息转换
* 字符显示过程

</br>

![](http://oczira72b.bkt.clouddn.com/18-1-2/8611091.jpg)
</br>
* 图形显示过程

</br>

![](http://oczira72b.bkt.clouddn.com/18-1-2/77354532.jpg)

</br>

7. 同步控制
* 字符方式：设置4级计数器

</br>

![](http://oczira72b.bkt.clouddn.com/18-1-3/30360457.jpg)

8. VRAM与ROM

</br>

![](http://oczira72b.bkt.clouddn.com/18-1-3/34394228.jpg)

</br>
VRAM与字符有关，RAM与字符的每一个点有关

9. APA方式（图像产生）
图形以像点(像素)为单位, 每8个像点为一个字节, 自左向右, 存放在VRAM一个编址单元中。
* 设置三级计数器

</br></br>

## 第六章 总线输入输出系统
#### 1. 接口分类
1. 按数据传送格式：并行接口，串行接口
2. 按时序控制方式：同步接口，异步接口
3. 按IO传送控制方式：程序控制接口，中断接口，DMA接口

#### 2. IO接口主要功能
1. 寻址
2. 数据缓冲
3. 预处理
4. 控制功能

#### 3. 总线
1. 定义：一组能为多个部件分时共享的信息传送线路。
2. 特点：分时共享
3. 实体：一组传送线与相应控制逻辑
4. 分类：
* 按功能(层次结构）划分：CPU内总线，局部总线、系统总线、外总线
* 按时序控制方式划分：同步总线、异步总线、扩展同步总线
* 按传输信号的类型：数据总线、地址总线、控制总线
* 按数据产送格式：并行总线、串行总线
5. 总结：
* CPU内总线：同步并行
* 局部总线：同步异步扩展同步，并行
* 系统总线：同上
* 外总线：异步，并行串行

#### 4. 直接程序传送及接口
1. 无条件传送
2. 条件传送（查询传送）：硬件开销小，并行程度低，实时性差，应用与对CPU要求不高的场合，或诊断、调试过程

#### 5. 程序中断方式及接口
1. 定义：CPU暂时中止现行程序的执行，转去执行为某个随机事态服务的中断处理程序。处理完毕后自动恢复原程序的执行。
2. 实质：程序切换
* 方法：保存断点，保护现场，恢复现场，返回断点
* 时间：一条指令节结束时切换保证程序的完整性
* 特点：随机性
3. 分类：根据中断源获取服务程序入口地址——向量中断，非向量中断
* 非向量中断：==由软件提供服务程序入口地址==
* 向量中断：==有硬件提供服务程序入口地址==
4. 中断系统的组成；
* 软件：中断服务程序+中断向量表（中断响应周期内,获取中断号,访问中断向量表,得到服务程序入口地址）
* 硬件：接口（中断请求、传递、判优逻辑）+CPU（中断响应逻辑）
5. 中断请求优先级判断
* 优先顺序：故障、内中断、DMA、外中断。==高速操作优于低俗操作，输入优于输出==
* CPU现行程序于外设请求的判优
*  * CPU设置允许中断标志
*  * CPU设置程序状态字的优先级字段
6. 中断响应：
* 获取中断程序的入口：
*  * 非向量中断：将服务程序入口组织在查询程序中，CPU响应时，执行查询程序，查询中断源，转入相应的服务程序。
*  * 向量中断：将中断源的服务程序入口（中断向量）组织在中断向量表中，CPU响应时，由硬件直接产生相应的向量地址，按地址查表，取得服务程序入口，转入相应的服务程序。
*  几个概念：
*  * 中断向量：中断服务程序入口地址
*  * 中断向量表：存放各中断向量的表（一段存储区）
*  * 向量地址：访问中断向量表地址（指向中断向量首地址），可以通过终端号（中断类型码）计算得到
*  响应过程：

</br>

![](http://oczira72b.bkt.clouddn.com/18-1-3/28736799.jpg)

7. 中断处理：
* 单级中断流程
```
graph LR
保护现场-->中断服务处理
中断服务处理-->恢复现场
恢复现场--> 开中断
开中断-->返回
```
* 多重中断流程

</br>

![](http://oczira72b.bkt.clouddn.com/18-1-3/39411252.jpg)

#### 6. DAM方式及接口
1. 定义（DMA: Direct Memory Access）：直接由硬件实现主存与I/O间的数据传送,传送期间不需CPU程序干预。传送结束以后，通过中断的方式通知CPU。
* 发生在IO与主存之间
* 由DMA控制器来控制传送，DMA控制器接管总线权，传送完毕再将总线权交换给CPU
* 只要CPU不访存，DMA操作与CPU可并行操作
* 传送前和传送后需要CPU程序干预
2. 特点与应用：
* 响应随机请求
* 一般不影响CPU程序的执行，仅占用总线，无程序切换
* 大批数据的简单传送
* 主要应用于：主存与IO之间的简单数据的传送；大批数据采集系统；动态存储器（RAM）的自动刷新
3. DMA传送过程
* DMA控制器功能：接受初始化信息（传送方向，主存首址，交换量）；接受外设DMA请求，判优，向CPU申请总线；接管总线权，发地址，读写命令。
* 接口功能：接受初始化信息（外设寻址信息）；向DMA控制器发请求；传送数据

</br>

![](http://oczira72b.bkt.clouddn.com/18-1-3/88094457.jpg)




## 问题：
1. 模型机是什么
2.转子指令与返回指令
3. AB\BD\CB是什么：地址总线，数据总线，控制总线
4. 接口和IO区别
5. 为什么模型机的图中有的线是单向有的双向
6. 置入：通过RS端，将数据置入MDR
打入：通过同步脉冲信号CP，将数据打入MDR
7. 模型机的运算部件为什么是16位，8选1
8. 模型机里面的控制信号是啥
9. CPU内部总线和外部总线是啥
10. 3.4的37页例题
11. 时钟脉冲，时钟周期（节拍），工作脉冲
12. “W”是什么意思</br>
![](http://oczira72b.bkt.clouddn.com/17-12-31/6796474.jpg)</br>
13. 什么叫转移？什么是转移不成功，为什么会不成功
14. 3.5ppt59页没看懂